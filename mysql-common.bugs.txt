.\mysql_common-0.35.5\src\proto\codec\mod.rs#527

if self.seq_id != chunk_info.seq_id() {
                    match comp_seq_id {
                        Some(seq_id) if seq_id == chunk_info.seq_id() => {
                            // server syncronized pkt_nr (in `net_flush`)
                            self.seq_id = seq_id;
                        }
                        _ => {
                            +++++++
                            self.seq_id = chunk_info.seq_id();                          <<<<<<<<<<<
                            -------
                            // return Err(PacketCodecError::PacketsOutOfSync);          <<<<<<<<<<<
                        }
                    }
                }

.\mysql_async-0.36.1\src\conn\binlog_stream\mod.rs#161

if first_byte == Some(0) {
    ++++++
            println!("packet: {:?}", packet);      
            let mut event_data = &packet[1..];
            if event_data[0] == 0xef {
                println!("slave semi-sync enabled");
                if event_data[1] == 1 {
                    println!("slave semi-sync status on");
                } else {
                    println!("slave semi-sync status off");
                }
                event_data = &packet[3..];
            } else {
                println!("slave semi-sync disabled");
            }
            // let event_data = &packet[1..];
    +++++++         
            match self.esr.read(event_data) {
                Ok(Some(event)) => {



./mysql_async-0.36.1/src/conn/binlog_stream/mod.rs

impl super::Conn {

// 响应ack
    pub async fn reply_ack(&mut self, position: u64, filename: &[u8]) -> Result<()> {
        let packet = SemiSyncAckPacket::new(position, filename);
        self.write_struct(&packet).await?;
        Ok(())
    }

}


./mysql_async-0.36.1/src/conn/binlog_stream/mod.rs

pub struct BinlogStream {
    read_packet: ReadPacket<'static, 'static>,
    esr: EventStreamReader,
    // TODO: Use 'static reader here (requires impl on the mysql_common side).
    /// Uncompressed Transaction_payload_event we are iterating over (if any).
    tpe: Option<Cursor<Vec<u8>>>,

    semi_sync: bool,
    need_reply: bool
}

impl BinlogStream {
    /// `conn` is a `Conn` with `request_binlog` executed on it.
    pub(super) fn new(conn: Conn) -> Self {
        BinlogStream {
            read_packet: ReadPacket::new(conn),
            esr: EventStreamReader::new(Version4),
            tpe: None,
            semi_sync: false,   <<<<
            need_reply: false,
        }
    }

127+++++

pub fn get_conn_mut(&mut self) -> &mut Conn {
        self.read_packet.conn_mut()
    }

pub fn get_semi_sync_status(&self) -> (bool, bool) {
        (self.semi_sync, self.need_reply)
    }


./mysql_async-0.36.1/src/io/read_packet.rs
35+++

#[cfg(feature = "binlog")]
    pub(crate) fn conn_mut(&mut self) -> &mut crate::Conn {
        self.0.as_mut()
    }