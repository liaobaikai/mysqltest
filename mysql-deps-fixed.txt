.\mysql_common-0.35.5\src\proto\codec\mod.rs#
527->UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU
if self.seq_id != chunk_info.seq_id() {
                    match comp_seq_id {
                        Some(seq_id) if seq_id == chunk_info.seq_id() => {
                            // server syncronized pkt_nr (in `net_flush`)
                            self.seq_id = seq_id;
                        }
                        _ => {
                            +++++++
                            self.seq_id = chunk_info.seq_id();                          <<<<<<<<<<<
                            -------
                            // return Err(PacketCodecError::PacketsOutOfSync);          <<<<<<<<<<<
                        }
                    }
                }




./mysql_async-0.36.1/src/conn/binlog_stream/mod.rs

impl super::Conn {

64++++++++++++++++++++++++++++++++++
    // reply_ack
    pub async fn reply_ack(&mut self, position: u64, filename: &[u8]) -> Result<()> {
        let packet = SemiSyncAckPacket::new(position, filename);
        self.write_command(&packet).await
    }



./mysql_async-0.36.1/src/conn/binlog_stream/mod.rs

pub struct BinlogStream {
    read_packet: ReadPacket<'static, 'static>,
    esr: EventStreamReader,
    // TODO: Use 'static reader here (requires impl on the mysql_common side).
    /// Uncompressed Transaction_payload_event we are iterating over (if any).
    tpe: Option<Cursor<Vec<u8>>>,
80++++++++++++++++++++++++++++++++++
    sync_flag: bool,
    need_reply: bool,
}

impl BinlogStream {
    /// `conn` is a `Conn` with `request_binlog` executed on it.
    pub(super) fn new(conn: Conn, filename: String) -> Self {
        BinlogStream {
            read_packet: ReadPacket::new(conn),
            esr: EventStreamReader::new(Version4),
            tpe: None,
91++++++++++++++++++++++++++++++++++
            semi_sync: false,
            need_reply: false,
        }
    }


123++++++++++++++++++++++++++++++++++

    pub fn get_conn_mut(&mut self) -> &mut Conn {
        self.read_packet.conn_mut()
    }

    pub fn get_semi_sync_status(&self) -> (bool, bool) {
        (self.semi_sync, self.need_reply)
    }



.\mysql_async-0.36.1\src\conn\binlog_stream\mod.rs#161

179->UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU
if first_byte == Some(0) {
            let mut event_data = &packet[1..];
            self.semi_sync = event_data[0] == 0xef;
            if event_data[0] == 0xef {
                self.need_reply = event_data[1] == 0x01;
                event_data = &packet[3..];
            }
            
            match self.esr.read(event_data) {


./mysql_async-0.36.1/src/io/read_packet.rs
35++++++++++++++++++++++++++++++++++

    #[cfg(feature = "binlog")]
    pub(crate) fn conn_mut(&mut self) -> &mut crate::Conn {
        self.0.as_mut()
    }